#pragma once

#include <vector>
#include <BumpyRenderer.hpp>
#include <DebugRenderer.hpp>

#include "SaveDataTypes.h"
#include "CustomXMLTypes.h"

#include "Animation.h"

class Chunk;
class World;

enum class EntityIDs { NPC_PLAYER, NPC_NEUTRAL_QUESTGIVER_A, NPC_NEUTRAL_COMPANIONCUBE, ITEM };

class Entity {
	friend class Scripter;

  public:
	Entity(glm::vec2 pos, unsigned int layer);
	Entity(SaveDataTypes::EntityData& saveData);
	virtual ~Entity();

	void init(SaveDataTypes::EntityData& data);

	void		 update(float timeStep, unsigned int selfIndex);
	void		 tick();
	virtual void draw(BARE2D::BumpyRenderer* renderer, float time, int layerDifference, float xOffset);
	void		 debugDraw(BARE2D::DebugRenderer* dr, float xOffset);
	void		 move(float timeStepVariable);

	virtual void collideWithTiles() {
	}
	virtual bool collideWithOther(Entity* other) {
		return false;
	} // Returns false if the X distance makes collision impossible

	// Getters
	const glm::vec2& getPosition() const {
		return m_position;
	}
	const glm::vec2& getSize() const {
		return m_size;
	}
	glm::vec2 getVelocity() const {
		return m_velocity;
	}
	glm::vec4 getLightLevel() const {
		return m_cornerLight;
	}
	float getAverageLightLevel() const {
		return (m_cornerLight.x + m_cornerLight.y + m_cornerLight.z + m_cornerLight.w) / 4.0f;
	}
	void setPosition(glm::vec2 pos) {
		m_position = pos;
	}
	unsigned int getLayer() const {
		return m_layer;
	}
	std::string getUUID() const {
		return m_UUID;
	}
	unsigned int getID() const {
		return m_id;
	}
	XMLModule::EntityType getType() const {
		return m_type;
	}

	void setToDraw(bool draw) {
		m_draw = draw;
	}

	void generateUUID();

	float getDepth() {
		/// Returns the depth for drawing.
		return 0.1f + (m_layer * (1.0f / (float)(WORLD_DEPTH)) * 0.9f);
	}

  protected:
	// Collision
	bool		 checkTilePosition(std::vector<glm::vec2>& collideTilePositions, float xPos, float yPos);
	virtual void collideWithTile(glm::vec2 tilePos, bool ground = false);

	void		 updateLightLevel();
	virtual void interact();

	void moveUpLayer();
	void moveDownLayer();

	void die();

	virtual void onUpdate(float timeStep, unsigned int selfIndex) {
	}
	virtual void onTick() {
	}
	virtual void onDraw(BARE2D::BumpyRenderer* renderer, float time, int layerDifference, float xOffset) {
	}

	virtual void animate(int& x, int& y, bool& flip, float time) {
	}

	bool m_controls[6]; // Up, down (crouching while on ground), left, right, backwards (layer++), forwards (layer--)

	bool	  m_exposedToSun = false;
	glm::vec4 m_cornerLight; // light values at each of the 4 corners. (clockwise, component 0 is at top left
	bool	  m_flippedTexture = false;

	glm::vec2	 m_position = glm::vec2(0.0f);
	unsigned int m_layer	= 0;
	glm::vec2	 m_velocity = glm::vec2(0.0f);
	bool		 m_onGround = false;
	bool		 m_draw		= true;

	// XML Attributes
	unsigned int m_id;

	BARE2D::Texture m_texture;
	BARE2D::Texture m_bumpmap;

	glm::vec2 m_size = glm::vec2(1.0f);

	BARE2D::LuaScript m_updateScript;
	BARE2D::LuaScript m_tickScript;

	bool m_gravity = true;

	XMLModule::EntityType m_type;

	// UUID
	std::string m_UUID =
		"NO_UUID"; // This is a universally unique identifier, and is generated by concatenating the current gametime, a few random numbers, and the position of this entity on creation
};
